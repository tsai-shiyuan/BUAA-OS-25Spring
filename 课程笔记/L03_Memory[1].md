# 内存管理概述

## 重要概念

### 存储体系

计算机存储器按照速度、容量和成本排列成层次结构

- **寄存器 (Registers):** 最快，容量最小，成本最高，直接由 CPU 访问
- **高速缓存 (Cache - L1, L2, L3):** 速度快，容量较小，成本高，用于缓解 CPU 和主存之间的速度差异
- **内存 (Main Memory / RAM):** 速度、容量和成本居中，是程序运行时代码和数据的主要存储区域
- **本地磁盘 (Local Disk / Secondary Storage):** 速度慢，容量大，成本低，用于持久化存储，如硬盘 (HDD)、固态硬盘 (SSD)
- **远程磁盘 (Remote Storage):** 通过网络访问，速度最慢，容量可以很大

**内存管理主要关注的是主存（内存）的管理**

### 地址空间

地址空间: 操作系统为每个进程分配的一个独立的逻辑地址范围。进程所能“看到”和访问的地址集合。

存储空间: 主存存储的物理单元，即物理地址

### 内碎片和外碎片

内存中无法被利用的存储空间称为碎片

- 内碎片: 分配给作业的存储空间中未被利用的部分
- 外碎片: 系统中无法利用的小的空闲分区 (如分区与分区之间存在的碎片)
- (感觉区别在于有没有被分配出去)

### 地址转换 (Address Translation)

- **定义:** 将用户程序中的**逻辑地址**转换为运行时可由机器直接寻址的**物理地址**的过程。也称**地址重定位 (Address Relocation)**、**地址变换 (Address Transformation)** 或**地址映射 (Address Mapping)**
- **目的:** 保证 CPU 执行指令时能够正确访问到物理内存单元
- 为什么需要?
  - 多道程序环境下，内存中有多个进程
  - 程序加载到内存的位置通常在运行时才能确定，无法在编译时预知其物理地址
- 地址绑定时机 (Binding Time): 指令和数据绑定到内存地址的时间点:
  - **编译时 (Compile Time):** 如果编译时就知道程序将驻留在内存的哪个位置，编译器可以直接生成绝对代码。但如果加载位置改变，程序就必须重新编译。很少用
  - **加载时 (Load Time):** 如果编译时不知道加载位置，编译器生成**可重定位代码 (Relocatable Code)**。加载器 (Loader) 在将程序加载到内存时，根据实际加载的起始地址，一次性地将所有逻辑地址转换为物理地址。这称为**静态地址重定位**
  - **运行时 (Run Time):** 地址转换延迟到程序运行时才进行。CPU 每次访问内存（取指或访存）时，都会将逻辑地址转换为物理地址。这需要硬件支持（如 MMU），称为**动态地址重定位**。现代操作系统普遍采用此方式，因为它提供了最大的灵活性（如进程可以在内存中移动）

#### 静态地址重定位 (Static Relocation)

- **过程:** 在程序被加载进内存时，由加载器一次性完成逻辑地址到物理地址的转换。

- **实现:** 通常由软件（加载器）完成

- 示例:

  ```bash
  // 源代码     // 目标代码 (逻辑地址)   // 装载模块 (磁盘, 逻辑)   // 装载模块 (内存, 物理 @ 1000)
  i = ...;     store 20;              store 120;              store 1120;
  f();         branch f;              branch 100;             branch 1100; // 假设 f 在 100
  ...          ...                    ...                     ...
  f: ...       f: ...                 f: ... (在 100)         f: ... (在 1100)
  ```

- **缺点:** 程序加载后不能在内存中移动；不灵活

#### 动态地址重定位 (Dynamic Relocation)

- **过程:** 在进程执行过程中，每次访问内存地址时进行转换。
- 实现: 需要硬件支持，通常是内存管理单元 (MMU - Memory Management Unit)
  - **MMU:** 一个硬件设备，负责将 CPU 发出的逻辑地址实时转换为物理地址
  - **实现方式 (简单示例):** 使用**基址寄存器 (Base Register)** 和**重定位寄存器 (Relocation Register)**。逻辑地址加上重定位寄存器的值得到物理地址
- **优点:** 进程可以在内存中移动（例如，为了内存紧凑）；支持更高级的内存管理技术（如虚拟内存）

#### 多重分区分配

思想: 一个作业往往由相对独立的程序段和数据段组成，将这些片断分别装入到存储空间中不同的区域内

程序段: 

- 程序主要由 bss 段、data 段、text 段组成
- bss段: 存放程序中未初始化的全局变量
- data段: 存放程序中已初始化的全局变量

### 存储共享

允许多个进程安全地共享同一段物理内存区域。例如，共享库（如 C 库）的代码段通常可以在多个进程间共享，只需在物理内存中保留一份副本，节省内存。实现通常依赖于分页或分段机制

### 局部性原理

程序在执行过程中的一个普遍倾向:

- 时间局部性: 一条指令的一次执行和下次执行、一个数据的一次访问和下次访问都集中在一个**较短时期内**，例如循环中的变量
- 空间局部性: 如果一个内存位置被访问，那么它**附近的内存位置**也很可能在不久的将来被访问，例如数组、顺序执行的代码

> 思考: 大数组排序，快排快还是堆排序快
>
> 快排最坏复杂度 $O(n^2)$ ，堆排序最坏复杂度 $O(n\log_2 n)$。但是快排能更好地利用cache

利用空间局部性，更高效的矩阵乘法:

```c
for (k = 0; k < n; k++) {
    for (i = 0; i < n; i++) {
        r = A[i][k];
        for (j = 0; j < n; j++) {
            C[i][j] += r * B[k][j];
        }
    }
}
```

## 物理内存管理

OS需要跟踪哪些物理内存是空闲的，哪些已被分配。

### 管理的数据结构

**位图 (Bitmap):**

- 将物理内存划分为固定大小的**分配单元**（通常大小等于页框或几倍页框大小）
- 每个分配单元赋予一个位，用来记录该分配单元是否闲置

**链表:**

- 维护一个包含所有空闲内存块信息的链表
- 每个节点/表项记录一个空闲区的起始地址 (Start Address) 和长度 (Length)
- 链表类型:
  - **隐式空闲链表 (Implicit Free List):** 空闲块和已分配块都存储在内存中，通过块头部信息（大小、是否空闲）来遍历。分配和回收时需要查找
  - **显式空闲链表 (Explicit Free List):** 只将**空闲块**链接起来。头部包含指向下一个（有时还有上一个）空闲块的指针。查找空闲块更快
  - **分离空闲链表 (Segregated Free List):** 维护多个空闲链表，每个链表负责特定大小范围的空闲块。分配时，根据请求大小直接去对应链表查找。可以加快分配速度，减少碎片。伙伴系统和 SLAB 分配器属于此类

### 内存分配算法 (针对链表)

如何在空闲区列表中选择一个合适的空闲块？

- 首次适应 First fit

- 下次适应 Next fit: 从上次查找结束的地方开始搜索

- 最佳适应 Best fit: 分配大小最接近的空白区

- 最坏适应 Worst fit: 寻找最大的空白区

**分配过程:** 选定一个空闲块后，如果其大小 `Size` 远大于请求大小 `s`，通常会将其**分割**为两部分: 一部分（大小为 `s`）分配给进程，另一部分（大小为 `Size - s`）变回一个新的、更小的空闲块

### 内存回收 (针对链表)

当一个进程释放内存块时，需要将其归还给空闲列表

- 合并 (Coalescing): 为了减少碎片，回收时需要检查该块是否与物理上相邻的空闲块接壤
  - **上相邻:** 与前面的空闲块合并
  - **下相邻:** 与后面的空闲块合并
  - **上下都相邻:** 与前后两个空闲块合并成一个大空闲块
  - **上下都不相邻:** 直接将回收块作为一个新的独立空闲块添加到链表/表中
- **更新数据结构:** 相应地修改空闲区表/链表

### 特定分配策略 - 伙伴系统

**伙伴系统 (Buddy System):**

- **思想:** 介于固定和可变分区间，已分配分区和空闲分区的大小均为2的k次幂，Linux内核采用

- **结构:** 将整个可用内存 (假设大小为 $2^U$ )看作一个块。维护 `U+1` 个空闲链表，分别管理大小为 $2^0$, $2^1$, …, $2^U$ 的空闲块
- 分配过程 (请求大小为 `s`):
  1. 计算满足需求的最小 2 的幂次 `k`，使得 $2^{k-1} < s \leqslant 2^k$
  2. 查找大小为 $2^k$ 的空闲链表
  3. 如果找到，分配该块
  4. 如果没找到，则查找更大的块 ($2^{k+1}$)。找到后，将其**分裂 (Split)** 成两个大小相等的**伙伴 (Buddies)** (均为 $2^k$)。一个用于分配，另一个放入 $2^k$ 的空闲链表
  5. 如果 $2^{k+1}$ 也没有，继续向上查找并递归分裂，直到找到可分配的块
- 回收过程 (释放大小为 $2^k$ 的块 `B`):
  1. 查找块 `B` 的**伙伴** `B'` (地址可以通过异或运算计算得到)
  2. 检查伙伴 `B'` 是否也空闲且大小相同 ($2^k$)
  3. 如果**是**，则将 `B` 和 `B'` **合并 (Merge)** 成一个更大的块 ($2^{k+1}$)，并递归尝试与新块的伙伴合并
  4. 如果**否**，则将 `B` 加入 $2^k$ 的空闲链表
- **优点:** 分裂和合并相对高效（伙伴地址计算快），能较好地控制外部碎片（合并机制）
- **缺点:** 存在**内碎片**（分配的块大小必须是 2 的幂，可能大于实际需求）

- 以1M内存为例:

![截屏2025-03-11 11.02.21](./images_buaa/%E6%88%AA%E5%B1%8F2025-03-11%2011.02.21.png)

## 内存管理方案

存储器的管理:

- 存储分配
- 地址变换
- 虚存的调度

### 单一连续区

使用: 适用于单道程序的内存管理，因为整个内存只有两个程序，用户程序和操作系统

实现: 用户程序每次都加载在同一个地方

### 固定式分区 (Fixed Partitioning)

- **适用:** 支持多道程序
- **特点:** 内存被预先划分成若干个**大小固定**的分区。分区大小可以相同也可以不同
- **分配:** 每个分区装入一个进程。当进程需要内存时，操作系统寻找一个足够大且空闲的分区分配给它
- 缺点:
  - **内碎片:** 分配给进程的分区可能大于进程实际需要的大小
  - **不灵活:** 分区大小固定，大进程可能无处容身，小进程占用大分区造成浪费

### 可变式分区 (Dynamic Partitioning)

- **特点:** 内存不预先划分，根据进程的实际需求，从**空闲内存 (洞 Hole)** 中动态地分割出一个分区分配给它
- **分配:** 使用 **First Fit, Best Fit, Worst Fit** 等算法在空闲区列表中查找并分配 (*某个区分出去过后，这个区的首地址会变*)
- **优点:** 按需分配，没有内碎片，比固定分区灵活
- **缺点:**
  - **外碎片:** 随着进程的分配和回收，内存中会产生许多不连续的小空闲区，即使总空闲量足够，也可能无法满足新的较大内存请求
  - 管理复杂: 需要维护空闲区列表，分配和回收时涉及查找、分割和合并

### 页式内存管理 (Paging) 🌟

**核心思想:**

- 把逻辑地址连续的程序分散存放到若干不连续的内存区域内
- **逻辑地址空间:** 划分为固定大小的块，称为**页 (Page)**
- **物理内存空间:** 划分为与页大小相同的块，称为**页框 (Page Frame)** /物理页面/内存块
- **分配:** 以**页**为单位进行。进程需要的页可以加载到**任意**空闲的页框中

**逻辑地址结构:** `逻辑地址 = 页号 (VPN) + 页内偏移 (Offset)`

- 例如，32位地址，页面大小 4KB ($2^{12}$B)，高 20 位 (31-12) 是页号，低 12 位 (11-0) 是页内偏移

**数据结构:**

- 进程**页表 (Page Table)**: 每个进程都有一个页表
  - 功能: 记录逻辑页号到物理页框号的映射关系
  - 页表项 (Page Table Entry - PTE): 至少包含**页框号**，通常还包含其他控制位:
    - **有效位/驻留位 (Valid/Present Bit):** 标记该页是否在物理内存中
    - **保护位 (Protection Bits):** 控制读/写/执行权限
    - **修改位 (Modified/Dirty Bit):** 标记该页加载到内存后是否被修改过
    - **访问位 (Accessed/Referenced Bit):** 标记该页是否被访问过
  - 存储: 页表本身也存储在**内存**中。操作系统通过**页表基址寄存器 (Page Table Base Register - PTBR)** (如 x86 的 CR3 寄存器) 指向当前进程的页表起始地址
- **空闲页框列表:** 操作系统需要维护一个数据结构（如位图或链表）来跟踪哪些物理页框是空闲的

**地址转换过程 (硬件 MMU):**

1. CPU 发出逻辑地址
2. MMU 将逻辑地址分解为**页号 `p`** 和**页内偏移 `d`**
3. 使用**页号 `p`** 作为索引，访问当前进程的**页表** (基址在 PTBR)
4. 找到对应的**页表项 (PTE)**
5. 检查 PTE 中的**有效位**和**保护位**。如果无效或权限不足，则产生**缺页异常 (Page Fault)** 或**保护异常**，陷入操作系统处理
6. 如果有效且权限允许，从 PTE 中取出**页框号 `f`**
7. 将**页框号 `f`** 与**页内偏移 `d`** 拼接（或 `f * PageSize + d`）得到最终的**物理地址**
8. 访问物理内存

**两级页表:** 

- 优点: 解决页表占用空间大的问题。只有实际使用的页表部分才需载入内存，虽然理论上总页表项数量不变，但实际上大多数进程只使用地址空间的一小部分
- 地址转换过程:

<img src="./images_buaa/%E6%88%AA%E5%B1%8F2025-03-19%2019.40.29.png" alt="截屏2025-03-19 19.40.29" style="zoom:33%;" />

- 缺点: 二级页表需要访问 3 次内存，时间开销增大

**TLB:**

- 为了提高地址转换效率，在CPU内部增加一些硬件单元，主要含:

  - TLB: 存放常用的逻辑地址与物理地址映射

  - TLB控制单元: TLB刷新，越界检查等

  - 页表遍历单元: TLB未命中时查找多级页表，将找到的物理地址送与TLB控制单元

<img src="./images_buaa/%E6%88%AA%E5%B1%8F2025-03-19%2019.52.31.png" alt="截屏2025-03-19 19.52.31" style="zoom:50%;" />

**反置页表:** 

- 原理: 以物理页号为索引，表项内容是逻辑页号

<img src="./images_buaa/%E6%88%AA%E5%B1%8F2025-03-19%2020.00.51.png" alt="截屏2025-03-19 20.00.51" style="zoom:33%;" />

- 访问流程:
  1. 用进程标志符和页号去检索反置页表 (虚拟地址通过hash映射到物理地址)
  2. 如果检索到与之匹配的表项，则表项的序号i便是该页的物理块号

<img src="./images_buaa/%E6%88%AA%E5%B1%8F2025-03-19%2020.02.23.png" alt="截屏2025-03-19 20.02.23" style="zoom:33%;" />

- 一种提升查找效率的方法: Hash

  <img src="./images_buaa/%E6%88%AA%E5%B1%8F2025-05-24%2014.49.54.png" alt="截屏2025-05-24 14.49.54" style="zoom:40%;" />

  - 由虚拟地址通过Hash算出一个物理地址，然后与该物理地址存的虚拟Page号比较，如果不一致，则根据Chain找下一项，如果一致，就读出Entry项，也就是实际物理页框号

### 段式内存管理 (Segmentation)

> 或许可以看作是页的大小可变的页式管理？

**核心思想:**

- **逻辑地址空间:** 按照程序的**逻辑结构**划分为多个**段 (Segment)**，如代码段、数据段、栈段等。每个段有自己的名字（通常用段号代替）和长度。**段的长度可以不同**

- **物理内存空间:** 仍然是线性地址空间，但分配时按**整个段**分配

- **分配:** 以**段**为单位。每个段需要分配一块**连续**的物理内存空间，但不同段之间可以不相邻

**逻辑地址结构:** `逻辑地址 = 段号 + 段内偏移`

**数据结构:**

  - 段表 (Segment Table): 每个进程一个段表，记录逻辑段号到物理内存信息的映射

    - 段表项 (Segment Table Entry - STE): 通常包含:

      - **段基址 (Segment Base):** 该段在物理内存中的起始地址
      - **段长 (Segment Limit):** 该段的长度
    
      - **保护位 (Protection Bits):** 如读/写/执行权限
    - 存储: 段表本身也存储在**内存**中。操作系统通过**段表基址寄存器 (Segment Table Base Register - STBR)** 指向当前进程的段表
  - **物理内存管理:** 类似于**可变分区**管理，需要维护空闲区列表

**地址转换过程 (硬件 MMU):**

![截屏2025-04-15 17.10.04](./images_buaa/%E6%88%AA%E5%B1%8F2025-04-15%2017.10.04.png)

1. CPU 发出逻辑地址，MMU 将逻辑地址分解为**段号 `s`** 和**段内偏移 `d`**
2. 使用**段号 `s`** 作为索引，访问当前进程的**段表** (基址在 STBR)
3. 找到对应的**段表项 (STE)**
4. 检查:
   - 段号 `s` 是否合法（在段表范围内）
   - 段内偏移 `d` 是否小于段限长 `Limit` (`0 <= d < Limit`)。如果超出，则产生**地址越界异常**
   - 访问权限是否允许。如果不允许，则产生**保护异常**
5. 如果检查通过，取出**段基址 `Base`**
6. 计算物理地址: **物理地址 = 段基址 `Base` + 段内偏移 `d`**
7. 访问物理内存

优点:

- 符合程序逻辑: 分段是用户可见的，便于程序员组织代码和数据
- 易于共享和保护: 可以方便地对整个逻辑段（如代码段）进行**共享**或设置保护属性

缺点:

- 外碎片: 段的长度可变，分配和回收类似于可变分区，会产生外碎片，需要紧缩技术
- 内存分配复杂: 需要找到足够大的连续空闲块

### 段页式管理 (Segmented Paging)

核心思想: 结合段式和页式的优点

- **用户视角 / 逻辑地址空间:** 仍然按**段**划分 (用户可见)
- **内存管理 / 物理内存:** 按**页框**划分和分配 (系统底层)
- **实现:** 每个**逻辑段**内部再进一步划分为**固定大小的页**

**逻辑地址结构:** `逻辑地址 = 段号 s + 段内页号 p + 页内偏移 d`

**数据结构:**

- 段表 (Segment Table): 每个进程一个
  - **段表项:** 不再直接指向物理基址，而是指向该**段对应的页表**的基址，并包含页表的长度（或段的页数）
- 页表 (Page Table): 每个段一个
  - **页表项:** 记录段内的逻辑页号到物理页框号的映射

**地址转换过程 (硬件 MMU):**

<img src="./images_buaa/%E6%88%AA%E5%B1%8F2025-03-20%2010.02.21.png" alt="截屏2025-03-20 10.02.21" style="zoom:33%;" />

1. CPU 发出逻辑地址 `(s, offset)` 
2. 从PCB中取出段表起始地址，用**段号 `s`** 查**段表**，找到对应段的**页表基址**和**段限长**
3. 检查**段内偏移 `offset`** 是否小于**段限长**。如果超出，则地址越界
4. 将**段内偏移 `offset`** 分解为**段内页号 `p`** 和**页内偏移 `d`**
5. 使用**段内页号 `p`** 作为索引，访问**该段的页表**（基址来自段表项），找到对应的**页表项 (PTE)**
6. 检查 PTE 的有效位和保护位
7. 从 PTE 中取出**页框号 `f`**
8. 计算物理地址: **物理地址 = 页框号 `f` \* PageSize + 页内偏移 `d`**
9. 访问物理内存

优点: 结合了段式的逻辑清晰、易于共享保护和页式的内存利用率高、无外碎片的优点

缺点:

- **系统开销大:** 需要维护段表和多个页表，增加了内存占用。
- **地址转换更复杂:** 需要多次内存访问（查段表 -> 查页表 -> 访问数据）。同样需要 TLB 来加速

## 内存“扩充”技术

在物理内存不足时，让系统能运行更大程序或更多进程的技术

### 覆盖技术 (Overlaying)

目的: 在物理内存小于程序总大小的情况下运行程序

原理: 把一个大的程序划分成一系列的覆盖，把程序执行时并不要求同时装入主存的覆盖组成一组，称其为覆盖段，这个覆盖段被分配到同一个存储区域

实现:

- **程序员负责:** 需要程序员手动划分程序模块，并指定它们之间的**覆盖结构 (Overlay Structure)**
- 操作系统提供加载覆盖模块的机制

### 交换技术 (Swapping)

目的: 提高内存利用率和系统吞吐量，允许运行的进程总大小超过物理内存

思想: 把暂时不用的某个/些程序及其数据的部分 (或全部) 从主存移到辅存 (交换区 Swap Space) 中去，以便腾出必要的存储空间；接着把指定程序或数据从辅存读到相应的主存中，并将控制转给它，让其在系统上运行

关键问题:

- **交换内容:** 进程的哪些部分需要交换？通常是进程的整个用户地址空间 (代码、数据、堆、栈等运行时状态)
- **交换位置:** 被换出的进程保存在磁盘的交换区
- 交换时机:
  - 内存空间不足时触发换出
  - 进程长时间阻塞或优先级低时可能被换出
  - 与**调度器**结合，选择合适的进程换入换出
- **换出进程选择:** 考虑进程状态 (例如可以换出等待 I/O 的进程)、优先级、在内存驻留时间等因素
- **换入位置:** 换回内存时不一定回到原来的物理地址。需要**动态地址重定位**支持

### 虚拟内存技术 (Virtual Memory)

允许程序只加载部分页面/段到内存即可运行，其余部分在需要时才从磁盘加载。这是现代操作系统普遍采用的核心内存管理技术。可以说虚拟内存综合了覆盖和交换的优势。

且听下回分解。

## Reference

- [Yutong Liang's blog](https://www.lyt0112.com/blog/operating_systems_note_05-zh)
- [CSDN｜启动与系统引导&程序装载](https://blog.csdn.net/JeremyZhao1998/article/details/104717397)
