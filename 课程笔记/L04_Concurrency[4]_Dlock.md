# 死锁

## 死锁问题 (Deadlock)

死锁发生原因: 

- 资源竞争
- 并发执行顺序不当

**死锁发生的四个必要条件:** 🌟

1. **互斥条件:** 在一段时间内某资源只由一个进程占用
2. **请求且占有条件:** 请求别的资源但对自己的资源无法释放。即指进程已经占有至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放
3. **不可剥夺条件:** 进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放
4. **环路等待条件:** 在发生死锁时，必然存在一个进程-资源的环形链，即进程集合 {P0, P1, P2, ···, Pn} 中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，…… ，Pn正在等待已被P0占用的资源

活锁和饥饿:

- **活锁 (livelock):** 任务没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。活锁与死锁的区别在于活锁的状态在不断发生改变，有可能自行解开
- **饥饿 (starvation):** 进程可能由于资源分配策略的不公平导致长时间等待

## 处理死锁的方法

处理死锁的方法:

- 不允许死锁发生
  - 预防死锁: 静态的，破坏产生死锁的必要条件
  - 避免死锁: 动态的，在资源分配之前进行判断
- 允许死锁发生
  - 检测死锁并解除

### 死锁预防

1. 打破互斥条件: 

   - 允许进程同时访问某些资源
   - 但有的资源本身不允许同时访问，比如打印机
2. 打破申请且占有条件: 

   - 只有当系统能够满足当前进程的全部资源需求时，才一次性地将所申请的资源全部分配给该进程，否则不分配任何资源
   - 缺点: 资源有时不可预测，并且拿到全部资源才执行会降低进程的并发性
3. 打破不可剥夺条件:

   - 允许进程强行从占有者那里夺取某些资源
   - 缺点: 实现困难
4. 打破循环等待条件:
   - 将资源有序分配。例如把资源事先分类编号，所有进程对资源的请求必须严格按资源序号递增的顺序提出。这样避免形成还路

### 死锁避免

安全序列: 一个进程序列 <P1, P2, ... , Pn> 是安全的，是指对于每一个进程 Pi，它需要的附加资源可以被系统中当前可用资源加上所有进程 Pj (j < i) 当前占有资源之和所满足 (就是前面的进程都能执行完成并且释放资源)

如果系统中不存在这样的安全序列，则系统是不安全的，但此时也未必会产生死锁

#### 银行家算法

Dijkstra, 1965

一个银行家把他的固定资金贷给若干顾客。假定顾客借款分成若干次进行；并在第一次借款时，能说明他的最大借款额。

具体流程: 顾客依次发送借款请求，银行家对当前顾客的借款操作进行判断，以确定其安全性 (能否支持顾客借款，直到全部归还) ；安全时，贷款；否则，暂不贷款

数据结构:

- n: 进程数量；m: 资源类型数
- 可利用资源向量 (Available): m维，Available[j] = k 表示系统中现有 Rj 类资源 k 个

- 最大需求矩阵 (Max): n $\times$ m
- 分配矩阵 (Allocation): 已经分配的资源数

![截屏2025-05-20 09.46.14](./images_buaa/%E6%88%AA%E5%B1%8F2025-05-20%2009.46.14.png)

算法:

- 设 Request_i 是进程 Pi 的请求向量，当 Pi 发出请求后，按如下步骤执行
  1. 如果 $\text{Request}_i \leqslant \text{Need}_i$ 则步入步骤2；否则出错
  2. 如果 $\text{Request}_i \leqslant \text{Available}$ 则步入步骤3；否则出错
  3. 系统试探把要求的资源分配给进程 Pi
  4. 执行安全性检测算法，如果系统分配后处于安全状态，则分配成功；否则，恢复分配前的状态，让进程 Pi 等待
- 安全性检测算法:
  - 就是看 Available 是否能依次满足所有进程的 Need

### 死锁检测

资源分配图:

- 大圆圈表示进程，矩形表示一类资源，矩形中的小圈代表每个资源
- P $\rightarrow$ R 表示进程 P 请求一个单位的 R 资源
- R $\rightarrow$ P 表示为进程 P 分配了一个单位的 R 资源

![截屏2025-05-20 19.02.18](./images_buaa/%E6%88%AA%E5%B1%8F2025-05-20%2019.02.18.png)

化简资源分配图: 找到所有资源请求都能被满足的进程，删掉其所有边，此时进程变为孤立点，反复进行

死锁定理: 系统中某个时刻 t 为死锁状态的充要条件是 t 时刻系统的资源分配图是不可完全化简的（不能消去所有的边）

### 死锁解除

两种方法:

- 撤消进程: 回退
- 剥夺资源: 挂起一些进程并剥夺其资源