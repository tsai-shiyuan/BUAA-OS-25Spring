# 进程线程调度

## CPU调度

CPU调度: 从就绪队列中选择一个进程，把CPU控制权交给它

分给谁(进程调度算法) $\rightarrow$ 什么时候切换(调度的时机) $\rightarrow$ 怎么切换(上下文切换)

### 调度的层次

高级调度/宏观调度/作业调度: 决定是否将新创建的进程纳入当前活跃进程集合（即是否允许进入内存和就绪队列）

中级调度/内外存交换: 决定哪些进程的部分或全部从内存换出到外存（挂起），以及何时将挂起的进程换回内存

低级调度/微观调度: 发生特定事件（如中断、系统调用、进程阻塞/唤醒、时间片用完等）后，需要选择下一个占用CPU的进程时，主要分为:

- 抢占式
  - 时间片原则
  - 优先权原则
  - 短作业优先
- 非抢占式: 实时性很差

![截屏2025-04-22 19.23.37](./images_buaa/%E6%88%AA%E5%B1%8F2025-04-22%2019.23.37.png)

### 调度时机

- 创建进程时，执行新进程还是继续执行父进程
- 进程运行完时
- 进程由于I/O、信号量等原因阻塞时
- I/O中断发生时，即某个I/O已完成，等待I/O的进程进入就绪态
- 在分时系统中，当一个时钟中断发生时

### 切换时机

OS取得CPU控制权时，就可能发生进程切换

- 用户调用: 例如读写文件，进程多半会被阻塞
- 陷阱: 指令出错会引起进程退出 (kill)
- 中断: 外部因素打断指令的执行，控制权移至中断处理程序

### 进程 (上下文) 切换步骤

- 保存处理器的上下文，包括程序计数器和其他寄存器
- 用新状态更新正在运行进程的PCB
- 把进程移至合适的队列: 就绪 or 阻塞
- 选择另一个要执行的进程，更新被选中的进程的PCB
- 被选中的进程装入CPU

## 处理器调度算法的设计

### 设计考量

**面向用户:**

- **周转时间:** 作业从提交到完成所经历的时间
  - 平均周转时间 T
  - 平均带权周转时间 T/Ts (Ts是CPU使用时间) : 这样就可能将用时比较长的作业放在后面
- **响应时间:** 用户输入请求到系统给出首次响应
- **截止时间:** 实时任务必须在规定时间前完成

- **优先级:** 可以使关键任务排在前
- **公平性:** 不能让进程长时间得不到调度

**面向系统:**

- **吞吐量:** 单位时间内完成的作业数
- **处理机利用率:** 忙碌时间/总时间
- **资源均衡利用:** CPU密集型 & I/O密集型搭配使用

面向算法本身的性能: 算法本身执行时间短

### 设计调度算法的要点

设计或选择调度算法时，需要考虑以下几个方面:

**进程优先级 (Priority):**

- **优先数:** 用于表示优先级的数值（数值越大优先级越高或越低，取决于系统定义）
- **静态优先级 (Static Priority):** 进程创建时指定，运行期间不变。简单，但可能不适应进程行为变化
- **动态优先级 (Dynamic Priority):** 进程优先级在运行过程中可以调整。例如，可以提升长时间等待的进程的优先级（老化, Aging），或降低长时间占用CPU进程的优先级。更能适应系统变化
- **PCB记录:** PCB中需要包含优先级信息

**进程就绪队列组织:**

- **单一队列:** 所有就绪进程放在一个队列中，按某种顺序（如FCFS、优先级）排列
- 多级队列 (Multiple Queues): 按进程属性（如优先级、类型）划分多个队列。不同队列可采用不同调度策略
  - **按优先级排队:** 每个优先级一个队列。调度器先服务高优先级队列
  - **按类型排队:** 如前台（交互）进程队列、后台（批处理）进程队列

**占用CPU的方式:**

- **非抢占式:** 一旦进程获得CPU，它将一直运行，直到**进程自己**因调用原语或等待I/O等原因进入阻塞状态，或时间片用完才让出处理器
- **抢占式:** 就绪队列中一旦有优先级高于当前运行进程优先级的进程存在时，便立即进行进程调度，把处理器转给优先级高的进程

**I/O密集型 vs CPU密集型进程 (I/O-bound vs. CPU-bound):**

- **调度倾向:** 现代系统通常倾向于优先调度I/O密集型进程，以保持I/O设备忙碌，提高系统整体吞吐量和响应性。让I/O进程尽快发出下一个I/O请求，然后在其等待时运行CPU密集型进程

**交互性分类:**

- 批处理进程: 无需与用户交互，通常在后台运行，不需很快的响应
- 交互式进程: 与用户交互频繁，因此要花很多时间等待用户输入，例如: word, 触控GUI
- 实时进程: 有实时要求，不能被低优先级进程阻塞，响应时间要短且要稳定

**时间片 (Time Slice / Quantum):**

- **定义:** 在抢占式调度（特别是轮转RR）中，分配给进程一次连续运行的最大CPU时间
- 选择:

  - 时间片无限大，就退化成进程不结束就无法退出的批处理系统
  - 时间片太小，执行几条指令就进行进程切换

## 设计调度算法

### 批处理系统

#### 先来先服务 (FCFS, First Come First Serve)

- 按照作业变成就绪状态的先后次序分派CPU，最简单
- 非抢占式

#### 短进程优先 (SJF, Shortest Job First)

- 对预计执行时间短的进程优先分配处理机
- 非抢占式

#### 最短剩余时间优先 (SRTF, Shortest Remaining Time First)

- 对短进程优先算法的改进。新就绪的进程如果比当前运行的进程有更短的时间，则先执行新进程
- **抢占式**
- 缺点: 长作业经常被打断

#### 最高响应比优先 (HRRF, Highest Response Ratio First)

- 是 FCFS 和 SJF 的平衡，每次调度时，都计算每个作业的响应比
- 响应比: RP = (已等待时间+预计运行时间) / 预计运行时间，选择值最大的作业运行
- 非抢占式

### 交互式系统

#### 时间片轮转 (RR, Round Robin)

![截屏2025-04-22 10.05.15](./images_buaa/%E6%88%AA%E5%B1%8F2025-04-22%2010.05.15.png)

- 机制:
  - **排队:** 将系统中所有的就绪进程按照FCFS原则，排成一个队列
  - **轮转:** 每次调度时将CPU分派给队首进程，让其执行一个时间片
  - **中断:** 在一个时间片结束时，发生**时钟中断**
  - **抢占:** 调度程序据此暂停当前进程的执行，将其送到就绪队列的末尾，并通过上下文切换执行当前的队首进程
  - **出让:** 进程可以未使用完一个时间片，就出让CPU（如阻塞）

#### 优先级算法 (Priority Scheduling)

![截屏2025-04-22 10.25.15](./images_buaa/%E6%88%AA%E5%B1%8F2025-04-22%2010.25.15.png)

- **静态优先级:** 
  - 创建进程时就确定，进程终止前都不改变
  - 依据:
    - 进程类型（系统进程优先级较高）
    - 对资源的需求（对CPU和内存需求较少的进程，优先级较高）
    - 用户要求（紧迫程度和付费多少）

- **动态优先级:**
  - 在创建进程时赋予的优先级，在进程运行过程中可以自动改变，以便获得更好的调度性能
  - 依据:
    - 在就绪队列中，等待时间延长则优先级提高
    - 进程每执行一个时间片，就降低其优先级
- 缺点:
  - **饥饿:** 低优先级进程可能永远无法运行。
  - **优先级反转 (Priority Inversion) / 优先级倒置:** 一个低优先级进程持有高优先级进程所需的资源（如锁），导致高优先级进程被迫等待低优先级进程。更糟的是，如果此时有一个中等优先级的CPU密集型进程就绪，它会抢占低优先级进程，使得高优先级进程的等待时间变得更长甚至不可预测
- 优先级反转解决方案:
  - **优先级继承 (Priority Inheritance):** 当高优先级进程等待低优先级进程持有的资源时，暂时将低优先级进程的优先级提升到与高优先级进程相同，使其能尽快运行并释放资源
  - **优先级天花板协议 (Priority Ceiling Protocol):** 给每个资源预设一个优先级上限（等于可能使用该资源的所有进程中的最高优先级）。当一个进程获得资源时，将其优先级提升到该资源的优先级上限。这能预防死锁并限制阻塞时间
  - **中断禁止:** 在临界区执行期间禁止中断（简单粗暴，在通用操作系统中通常不可取，但用于某些嵌入式或实时内核）

#### 多级队列算法 (MQ, Multiple-level Queue)

引入多个就绪队列，每个作业固定归入一个队列，各队列的区别对待 (不同队列可有不同的优先级、时间片长度、调度策略等)。例如:

- 系统进程队列 (最高优先级, RR 或 FCFS)
- 交互式进程队列 (中优先级, RR)
- 批处理进程队列 (最低优先级, FCFS)

调度器首先处理高优先级队列中的所有进程，然后才处理次高优先级队列，以此类推。队列之间通常是抢占式的 (高优先级队列进程可抢占低优先级队列进程)

![截屏2025-04-22 20.37.07](./images_buaa/%E6%88%AA%E5%B1%8F2025-04-22%2020.37.07.png)

#### 多级反馈队列 (MFQ, Multi-level Feedback Queue)

- **实现:**
  - 设置多个就绪队列 (Q0, Q1, …, Qn)，优先级 Q0 > Q1 > … > Qn
  - 不同队列分配不同的时间片长度，优先级越高的队列时间片越短（如 Q0=q, Q1=2q, Q2=4q…）
  - 新进程进入内存后，先投入最高优先队列 Q0 末尾，按 RR 调度
  - 如果进程在一个队列中用完了其时间片但未完成，它会被**降级**到下一个较低优先级队列
  - 最低优先级队列通常采用FCFS或很长的时间片RR
  - 仅当较高优先级的队列为空，才调度较低优先级的队列中的进程执行。如果进程执行时有新进程进入较高优先级的队列，则抢先执行新进程，并把被抢先的进程投入原队列的末尾

### 实时系统

计算机必须在一个确定的**时间范围内做出反应**，实时系统分为硬实时系统和软实时系统。硬实时系统要求绝对满足截止时间要求（如：汽车和飞机的控制系统），而软实时调度可以偶尔不满足

**要求:**

- 需要更详细的调度信息，如: 就绪时间、开始或完成截止时间、处理时间、资源要求、绝对或相对优先级
- **抢占式调度**
- 快速中断响应，在中断处理时（硬件）关中断的时间尽量短
- 快速任务分派，相应地采用较小的调度单位，如线程

一些参数: 假设任务集 $S = \{t_1, t_2, \cdots , t_n\}$ 

- 周期: $T_1, T_2, \cdots, T_n$ 
- 执行时间: $C_1, C_2, \cdots, C_n$
- 截止时间: $D_1, D_2, \cdots, D_n$ (通常 $D_i = T_i$ )
- CPU利用率: $U = \sum\limits_{i=1}^{n}\frac{C_i}{T_i}$

#### 静态表调度算法

- 通过对所有周期性任务的分析预测，事先确定一个固定的调度方案

#### 单调速率调度 (RMS, Rate Monotonic Scheduling)

- **类型:** 静态优先级，抢占式
- **策略:** 任务的优先级根据其**周期** (Rate) 设定，周期越短（频率越高），优先级越高
- **适用:** 周期性实时任务
- **优点:** 简单，理论成熟，可进行精确的可调度性分析，Liu & Layland 条件：$\sum\limits_{i=1}^{n}\frac{C_i}{T_i} \leqslant n(\sqrt[n]{2}-1)$ 
- **缺点:** 仅适用于周期任务，对任务集利用率上限有要求 (不是100%)

**最早截止时间优先 (EDF, Earliest Deadline First):**

- **类型:** 动态优先级，抢占式
- **策略:** 调度器在每次调度时，选择就绪队列中**绝对截止时间 (Deadline)**最早的任务运行
- **适用:** 周期性和非周期性实时任务
- **优点:** 理论上是最优的动态优先级算法，只要 $\sum\limits_{i=1}^{n}\frac{C_i}{T_i}\leqslant 1$，EDF就能找到一个可行的调度。CPU利用率上限可达100%
- **缺点:** 实现比RM复杂（需要跟踪每个任务的截止时间），可能出现瞬时过载导致多米诺骨牌效应（一个任务错过deadline可能导致后续任务都错过）

#### 最低松弛度优先算法 (LLF, Least Laxity First)

$$
松弛度 (Laxity) = 进程截止时间-本身剩余运行时间-当前时间
$$

- 松弛度越小表示越紧急，优先进行调度
- 进程执行完或有进程松弛度为0时，将进行调度，抢占处理机

### 多处理机调度

**非对称式多处理系统 (AMP, Asymmetric Multi-Processor):**

- 多处理器系统中各个处理器的地位不同
- 主-从处理机系统，由主处理机管理一个公共就绪队列，并分派进程给从处理机执行。各个处理机有固定分工，如执行OS的系统功能，I/O处理，应用程序

**对称式多处理系统 (SMP, Symmetric Multi-Processor):**

- 各个处理器的地位相同
- 集中控制: 两种分配方式
  - 静态分配 (static assignment): 每个CPU设立一个就绪队列，进程从开始执行到完成，都在同一个CPU上
  - 动态分配 (dynamic assignment): 所有CPU采用一个公共就绪队列，队首进程每次分派到当前空闲的CPU上执行。可防止系统中多个处理器忙闲不均
- 分散控制: 自调度
  - 整个系统采用一个公共就绪队列，每个处理机都可以从队列中选择适当进程来执行

### Linux调度

**Linux调度算法演化:**

- **Linux 2.4:** 
  - 简单 O(n) 调度器（全局队列）。基于优先级和时间片。遍历整个可运行队列找最高优先级进程。所有进程时间片用完后统一重新计算。对交互式进程通过剩余时间片补偿来提升优先级
  - **缺点:** 扩展性差（高负载时慢），交互性优化不完善（前后分到不同的CPU，缓存效率降低），非抢占内核
- Linux 2.6.0: O(1) 调度器 (by Ingo Molnar):
  - 引入 active/expired 两个优先级数组队列。调度只需 O(1) 时间找到最高优先级非空队列
  - 动态优先级基于静态优先级(nice值)和平均睡眠时间 bonus 计算，试图区分交互式/批处理
  - 进程时间片用完后移入 expired 队列（除非是特殊情况）。active 队列空后，交换 active 和 expired 指针
  - **缺点:** 区分交互式的启发式规则，复杂难懂且易失效，代码难维护
- Linux 2.6 (中期): SD (Staircase Scheduler by Con Kolivas) / RSDL (Rotating Staircase Deadline Scheduler):
  - 追求公平，抛弃复杂动态优先级
  - **SD:** 进程用完时间片后优先级降低一级（下楼梯），到底后回到较高层并获更多时间片。交互进程睡眠时停留在高层，唤醒后响应快
  - **RSDL:** 引入 group quota (Tg) 和 expired 数组。高优先级组用完 Tg 后整体降级（minor rotation），保证低优先级任务的可预测等待时间。时间片用完进 expired 队列。active 队列空或到底后触发 major rotation (交换 active/expired)
  - **影响:** 启发了CFS的公平思想
- Linux 2.6.23 至今: CFS (Completely Fair Scheduler by Ingo Molnar):
  - **核心思想:** 完全公平。理想情况下，每个进程获得 1/n 的CPU时间。不再区分交互式/批处理，不再使用固定时间片
  - **虚拟运行时间 (vruntime):** `vruntime` 记录进程的加权运行时间。`vruntime` 增长速度与实际运行时间成正比，与进程权重（优先级）成反比。 `vruntime ≈ 实际运行时间 * (NICE_0_LOAD / 进程权重)` (NICE_0_LOAD 是 nice=0 进程的权重)
  - **调度决策:** 总是选择就绪队列中 **`vruntime` 最小** 的进程运行
  - **数据结构:** 使用**红黑树 (Red-Black Tree)**存储就绪进程，按 `vruntime` 排序。插入、删除、查找最小节点都是 O(log n) 时间。调度器取最左节点运行
  - **公平性实现:** 优先级高的进程权重高，`vruntime` 增长慢，更容易被选中；优先级低的进程权重低，`vruntime` 增长快。最终达到按权重比例分配CPU时间的效果
- Linux 6.6+ (实验性/可选): EEVDF (Earliest Eligible Virtual Deadline First):
  - 对CFS的改进，旨在解决CFS在极短任务和延迟敏感任务上的一些问题，进一步改善延迟和公平性。它结合了虚拟时间和截止时间的概念
