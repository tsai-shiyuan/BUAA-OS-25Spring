# 进程线程模型

## 进程模型

进程应该包括:

- 程序段
- 数据段
- 进程控制块PCB

<img src="./images_buaa/%E6%88%AA%E5%B1%8F2025-04-01%2009.14.23.png" alt="截屏2025-04-01 09.14.23" style="zoom: 33%;" />

进程控制的任务由**内核**实现，主要负责:

- 创建和撤消进程
- 实现进程的状态转换

### 进程控制原语

**原语** (Primitive) 是完成某种特定功能的指令序列，具有不可分割性，即原语的执行必须是连续的，在执行过程中不允许被中断，也称为原子操作 (Atomic)

原语必须在**内核**态下执行，且常驻内存

执行 `fpid=fork()` 后，就变成**两个进程**执行随后的代码

- 在子进程中 `fork` 函数返回值为 `0` 
- 在父进程中 `fork` 返回新创建子进程的ID
- 如果出现错误，`fork` 返回负值

### 进程状态

- 就绪状态: 进程已获得除CPU外的所需资源，等待分配，只要分配CPU就可执行
- 执行状态
- 阻塞状态: 正在执行的进程，由于发生某种事件而暂时无法执行，便放弃CPU

<img src="./images_buaa/%E6%88%AA%E5%B1%8F2025-04-01%2009.26.45.png" alt="截屏2025-04-01 09.26.45" style="zoom: 25%;" />

### 进程控制块 (Process Control Block, PCB)

**定义:** 操作系统用于管理进程的核心数据结构，是进程存在的唯一标志

**作用:** 保存进程状态、资源、上下文等信息，供OS进行调度和管理

主要内容:
- **进程描述信息:** PID (唯一标识), 进程名, 用户ID (UID), 进程组关系
- 进程控制信息:
  - 当前状态 (State)
  - 优先级 (Priority)
  - CPU现场信息 (Context): 程序计数器 (PC), 各种CPU寄存器, 程序状态字 (PSW), 栈指针 (SP)。**这是进程切换时需要保存和恢复的关键信息**
  - 调度相关信息 (如等待事件、时间片等)
- 所拥有的资源和使用情况:
  - 虚拟地址空间描述 (指向页表/段表的指针)
  - 打开文件列表
  - I/O设备信息
- **进程间通信与同步信息:** 消息队列指针, 信号量等
- **记账信息:** CPU使用时间, 内存使用量等

**具体实现:** 不同OS有不同结构，如 Linux 的 `task_struct`, Windows 的 `EPROCESS`/`KPROCESS`/`PEB`, Solaris 的 `proc_t`。真实系统中的PCB结构非常庞大复杂。ps. Windows内核有明确的线程和进程概念

### 进程上下文切换 (Process Context Switch)

**定义:** 将CPU的控制权从一个进程（或线程）转移给另一个进程（或线程）的过程。这涉及到保存当前进程的状态并加载新进程的状态

**上下文 (Context):** 进程运行时，其执行状态 (硬件上下文) 保存在CPU的寄存器中 (如程序计数器PC, 程序状态字PSW, 栈指针SP, 通用寄存器等)。进程不运行时，这些信息保存在其**进程控制块 (PCB)** 中

主要工作:

1. **切换地址空间:** 修改页目录寄存器 (如CR3 on x86) 以指向新进程的页表，加载新的虚拟地址空间
2. **切换内核栈和硬件上下文:**
   - 保存当前进程的寄存器值到其PCB或内核栈
   - 从新进程的PCB或内核栈中恢复其寄存器值到CPU
   - 内核栈 (Kernel Stack):
     - 每个进程都有自己的内核栈，用于在进程执行内核代码时存储函数调用、局部变量和上下文信息
     - 当进程从用户态切换到内核态 (如系统调用、中断) 时，CPU会自动切换到该进程的内核栈
     - 内核栈位于内核地址空间，对用户程序不可见，大小通常是固定的 (如 Linux 中为 8KB 或 16KB)
     - 内核栈的地址通常保存在进程的 PCB 中，在上下文切换时需要更新相关寄存器（如栈指针）指向新进程的内核栈

具体步骤 (进程A切换到进程B):

1. 保存进程A的硬件上下文（寄存器值）
2. 更新进程A的PCB（如状态改为就绪或阻塞，记录PC等）
3. 将进程A移入相应的队列（就绪队列、等待队列）
4. 选择进程B作为下一个运行进程
5. 更新进程B的PCB（状态改为运行）
6. 加载进程B的上下文（恢复寄存器值，切换地址空间）
7. 开始执行进程B

上下文切换开销 (Cost):

- 直接开销: 内核执行切换操作所花费的CPU时间
  - 保存和恢复寄存器
  - 切换地址空间 (TLB Flush相关指令通常较昂贵)
  - 执行调度算法本身的代码
- 间接开销: 切换导致缓存性能下降
  - **CPU Cache 失效:** 新进程的代码和数据不在缓存中，需要从内存加载
  - **TLB (Translation Lookaside Buffer) 失效:** 地址翻译缓存失效，需要重新查询页表
  - **缓冲区缓存 (Buffer Cache) 可能失效:** 文件系统相关的缓存可能对新进程无效

## 线程模型 (Thread Model)

现代操作系统将资源拥有者称为进程，可执行单元称为线程

**进程是资源分配的基本单位，线程是处理机调度的基本单位**，线程只有少数的线程栈数据，这样实现了资源与计算分离，提高并发效率

(多线程更容易发生死锁，因为共享资源更多)

## 线程的实现

### 用户级线程 (User-Level Threads, ULT)

线程在用户空间，通过library**模拟**的thread，不需要或仅需要极少的kernel支持

例子:

- Java Threads
- POSIX Pthreads: C语言的多线程标准API，规定了线程库的行为，但不限定实现方法

优点:

- 线程切换与内核无关
- 线程的调度由应用决定，容易进行优化
- 可运行在任何操作系统上，只需要线程库的支持

不足: 

- 内核只能将处理器分配给进程，即使有多个处理器，也无法实现一个进程中的多个线程的并行执行

### 内核级线程 (Kernel-Level Threads, KLT)

内核层面创建多线程，例子有: Linux, Solaris, etc

优点: 

- 内核可以在多个处理器上调度一个进程的多个线程实现同步并行执行
- 阻塞发生在线程级别
- 内核中的一些处理可以通过多线程实现

缺点:

- 一个进程中的线程切换需要内核参与，降低效率

### 混合线程

使用内核级线程，然后将用户级线程与某些或者全部内核线程多路复用。内核只识别内核级线程，并对其进行调度。线程在用户空间创建和管理，需要实现从用户空间的线程到内核空间线程（轻量级进程）的映射

## 线程安全

若一个程序或子程序可以“在任意时刻被中断然后操作系统调度执行另一段代码，这段代码又使用了该副程序不会出错”，则称其为**可重入** (reentrant)。简单理解为: 可以被中断、且重新进入也不会出错的函数。
